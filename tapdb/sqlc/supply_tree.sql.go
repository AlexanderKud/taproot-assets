// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: supply_tree.sql

package sqlc

import (
	"context"
	"database/sql"
)

const DeleteUniverseSupplyLeaf = `-- name: DeleteUniverseSupplyLeaf :exec
DELETE FROM universe_supply_leaves
WHERE leaf_node_namespace = $1 AND leaf_node_key = $2
`

type DeleteUniverseSupplyLeafParams struct {
	Namespace   string
	LeafNodeKey []byte
}

func (q *Queries) DeleteUniverseSupplyLeaf(ctx context.Context, arg DeleteUniverseSupplyLeafParams) error {
	_, err := q.db.ExecContext(ctx, DeleteUniverseSupplyLeaf, arg.Namespace, arg.LeafNodeKey)
	return err
}

const DeleteUniverseSupplyLeaves = `-- name: DeleteUniverseSupplyLeaves :exec
DELETE FROM universe_supply_leaves
WHERE supply_root_id = (
    SELECT id FROM universe_supply_roots WHERE namespace_root = $1
)
`

func (q *Queries) DeleteUniverseSupplyLeaves(ctx context.Context, namespaceRoot string) error {
	_, err := q.db.ExecContext(ctx, DeleteUniverseSupplyLeaves, namespaceRoot)
	return err
}

const DeleteUniverseSupplyRoot = `-- name: DeleteUniverseSupplyRoot :exec
DELETE FROM universe_supply_roots
WHERE namespace_root = $1
`

func (q *Queries) DeleteUniverseSupplyRoot(ctx context.Context, namespaceRoot string) error {
	_, err := q.db.ExecContext(ctx, DeleteUniverseSupplyRoot, namespaceRoot)
	return err
}

const FetchUniverseSupplyRoot = `-- name: FetchUniverseSupplyRoot :one
SELECT r.group_key, n.hash_key as root_hash, n.sum as root_sum
FROM universe_supply_roots r
JOIN mssmt_roots m
    ON r.namespace_root = m.namespace
JOIN mssmt_nodes n
    ON m.root_hash = n.hash_key AND
       m.namespace = n.namespace
WHERE r.namespace_root = $1
`

type FetchUniverseSupplyRootRow struct {
	GroupKey []byte
	RootHash []byte
	RootSum  int64
}

func (q *Queries) FetchUniverseSupplyRoot(ctx context.Context, namespaceRoot string) (FetchUniverseSupplyRootRow, error) {
	row := q.db.QueryRowContext(ctx, FetchUniverseSupplyRoot, namespaceRoot)
	var i FetchUniverseSupplyRootRow
	err := row.Scan(&i.GroupKey, &i.RootHash, &i.RootSum)
	return i, err
}

const QuerySupplyLeavesByHeight = `-- name: QuerySupplyLeavesByHeight :many
SELECT
    leaves.script_key_bytes,
    gen.gen_asset_id,
    nodes.value AS supply_leaf_bytes,
    nodes.sum AS sum_amt,
    gen.asset_id,
    leaves.block_height
FROM universe_leaves AS leaves
JOIN mssmt_nodes AS nodes
    ON leaves.leaf_node_key = nodes.key
    AND leaves.leaf_node_namespace = nodes.namespace
JOIN genesis_info_view AS gen
    ON leaves.asset_genesis_id = gen.gen_asset_id
WHERE
    leaves.leaf_node_namespace = $1 AND
    (leaves.block_height >= $2 OR $2 IS NULL) AND
    (leaves.block_height <= $3 OR $3 IS NULL)
`

type QuerySupplyLeavesByHeightParams struct {
	Namespace   string
	StartHeight sql.NullInt32
	EndHeight   sql.NullInt32
}

type QuerySupplyLeavesByHeightRow struct {
	ScriptKeyBytes  []byte
	GenAssetID      int64
	SupplyLeafBytes []byte
	SumAmt          int64
	AssetID         []byte
	BlockHeight     sql.NullInt32
}

func (q *Queries) QuerySupplyLeavesByHeight(ctx context.Context, arg QuerySupplyLeavesByHeightParams) ([]QuerySupplyLeavesByHeightRow, error) {
	rows, err := q.db.QueryContext(ctx, QuerySupplyLeavesByHeight, arg.Namespace, arg.StartHeight, arg.EndHeight)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuerySupplyLeavesByHeightRow
	for rows.Next() {
		var i QuerySupplyLeavesByHeightRow
		if err := rows.Scan(
			&i.ScriptKeyBytes,
			&i.GenAssetID,
			&i.SupplyLeafBytes,
			&i.SumAmt,
			&i.AssetID,
			&i.BlockHeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const QueryUniverseSupplyLeaves = `-- name: QueryUniverseSupplyLeaves :many
SELECT r.group_key, l.sub_tree_type,
       smt_nodes.value AS sub_tree_root_hash, smt_nodes.sum AS sub_tree_root_sum
FROM universe_supply_leaves l
JOIN mssmt_nodes smt_nodes
  ON l.leaf_node_key = smt_nodes.key AND
     l.leaf_node_namespace = smt_nodes.namespace
JOIN universe_supply_roots r
  ON l.supply_root_id = r.id
WHERE r.id = $1 AND
      (l.sub_tree_type = $2 OR $2 IS NULL)
`

type QueryUniverseSupplyLeavesParams struct {
	SupplyRootID int64
	SubTreeType  sql.NullString
}

type QueryUniverseSupplyLeavesRow struct {
	GroupKey        []byte
	SubTreeType     string
	SubTreeRootHash []byte
	SubTreeRootSum  int64
}

func (q *Queries) QueryUniverseSupplyLeaves(ctx context.Context, arg QueryUniverseSupplyLeavesParams) ([]QueryUniverseSupplyLeavesRow, error) {
	rows, err := q.db.QueryContext(ctx, QueryUniverseSupplyLeaves, arg.SupplyRootID, arg.SubTreeType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryUniverseSupplyLeavesRow
	for rows.Next() {
		var i QueryUniverseSupplyLeavesRow
		if err := rows.Scan(
			&i.GroupKey,
			&i.SubTreeType,
			&i.SubTreeRootHash,
			&i.SubTreeRootSum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertUniverseSupplyLeaf = `-- name: UpsertUniverseSupplyLeaf :one
INSERT INTO universe_supply_leaves (
    supply_root_id, sub_tree_type, leaf_node_key, leaf_node_namespace
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (supply_root_id, sub_tree_type)
    -- This is a no-op to allow returning the ID.
    DO UPDATE SET sub_tree_type = EXCLUDED.sub_tree_type
RETURNING id
`

type UpsertUniverseSupplyLeafParams struct {
	SupplyRootID      int64
	SubTreeType       string
	LeafNodeKey       []byte
	LeafNodeNamespace string
}

func (q *Queries) UpsertUniverseSupplyLeaf(ctx context.Context, arg UpsertUniverseSupplyLeafParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertUniverseSupplyLeaf,
		arg.SupplyRootID,
		arg.SubTreeType,
		arg.LeafNodeKey,
		arg.LeafNodeNamespace,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const UpsertUniverseSupplyRoot = `-- name: UpsertUniverseSupplyRoot :one
INSERT INTO universe_supply_roots (namespace_root, group_key)
VALUES ($1, $2)
ON CONFLICT (namespace_root)
    -- This is a no-op to allow returning the ID.
    DO UPDATE SET namespace_root = EXCLUDED.namespace_root
RETURNING id
`

type UpsertUniverseSupplyRootParams struct {
	NamespaceRoot string
	GroupKey      []byte
}

func (q *Queries) UpsertUniverseSupplyRoot(ctx context.Context, arg UpsertUniverseSupplyRootParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpsertUniverseSupplyRoot, arg.NamespaceRoot, arg.GroupKey)
	var id int64
	err := row.Scan(&id)
	return id, err
}
